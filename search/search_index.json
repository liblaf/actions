{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GitHub Actions Collection","text":"<p>This repository contains a collection of GitHub Actions designed to automate various tasks within your GitHub workflows. Each action is tailored to perform specific functions, enhancing the efficiency and reliability of your CI/CD pipelines.</p>"},{"location":"#actions-included","title":"Actions Included","text":"<ul> <li>auth-app: Authenticates with a GitHub App to generate an installation access token for specified repositories.</li> <li>auto-merge: Automatically merges pending pull requests generated by Release-Please, filtering by GitHub App author and label.</li> <li>install: Installs software packages using various package managers (APT, Homebrew, Chocolatey, eget, Linuxbrew, NPM, and pipx) based on the operating system and inputs provided.</li> <li>release: Automates the process of creating a release on GitHub, including generating a changelog, formatting it, and uploading specified assets.</li> </ul>"},{"location":"#usage","title":"Usage","text":"<p>Each action is designed to be used independently within your GitHub workflows. Refer to the individual action's README for detailed usage instructions and examples.</p>"},{"location":"#example-workflow","title":"Example Workflow","text":"<pre><code>name: Example Workflow\n\non: [push]\n\njobs:\n  authenticate:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n\n      - name: Authenticate with GitHub App\n        uses: liblaf/actions/auth-app@main\n        with:\n          app-id: ${{ secrets.APP_ID }}\n          private-key: ${{ secrets.PRIVATE_KEY }}\n\n  install:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n\n      - name: Install Packages\n        uses: liblaf/actions/install@main\n        with:\n          apt: \"package1 package2\"\n          brew: \"package3 package4\"\n\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n\n      - name: Create Release\n        uses: liblaf/actions/release@main\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          tag: v1.0.0\n          clobber: true\n          prerelease: false\n          hasher: sha256\n          files: |\n            dist/*.tar.gz\n            dist/*.zip\n</code></pre>"},{"location":"#external-links","title":"External Links","text":"<p>Explore how this project is used in real-world scenarios:</p> <ul> <li>bot-auto-merge.yaml at liblaf/actions</li> <li>ci.yaml at liblaf/python-cli</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License. See the LICENSE file for details.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please read the CONTRIBUTING.md file for guidelines on how to contribute to this project.</p>"},{"location":"#issues","title":"Issues","text":"<p>If you encounter any issues or have suggestions for improvements, please open an issue on the GitHub repository.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>HOME</li> <li>API Reference</li> </ul>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>liblaf     * liblaf.actions         * liblaf.actions.actions             * liblaf.actions.actions.release             * liblaf.actions.actions.review             * liblaf.actions.actions.ruleset_import         * liblaf.actions.core         * liblaf.actions.github         * liblaf.actions.utils             * liblaf.actions.utils.cksum                 * liblaf.actions.utils.cksum.filename</li> </ul>"},{"location":"api/liblaf/actions/","title":"liblaf.actions","text":"<p>Modules:</p> <ul> <li> <code>actions</code>           \u2013            </li> <li> <code>core</code>           \u2013            </li> <li> <code>github</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>Inputs</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>run</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/actions/#liblaf.actions.Inputs","title":"Inputs","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Attributes:</p> <ul> <li> <code>model_config</code>           \u2013            </li> </ul>"},{"location":"api/liblaf/actions/#liblaf.actions.Inputs.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(\n    env_prefix=\"INPUT_\", cli_parse_args=True\n)\n</code></pre>"},{"location":"api/liblaf/actions/#liblaf.actions.run","title":"run","text":"<pre><code>run(func: ActionFunction[T]) -&gt; None\n</code></pre> Source code in <code>src/liblaf/actions/_run.py</code> <pre><code>def run[T: Inputs](func: ActionFunction[T]) -&gt; None:\n    grapes.init_logging()\n    type_hints: dict[str, type[T]] = get_type_hints(func)\n    cls: type[T] = type_hints[\"inputs\"]\n    inputs: T = cls()\n    asyncio.run(func(inputs))\n</code></pre>"},{"location":"api/liblaf/actions/actions/","title":"liblaf.actions.actions","text":"<p>Modules:</p> <ul> <li> <code>release</code>           \u2013            </li> <li> <code>review</code>           \u2013            </li> <li> <code>ruleset_import</code>           \u2013            </li> </ul>"},{"location":"api/liblaf/actions/actions/release/","title":"liblaf.actions.actions.release","text":"<p>Classes:</p> <ul> <li> <code>Client</code>           \u2013            </li> <li> <code>Inputs</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>main</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Client","title":"Client","text":"<pre><code>Client(owner: str, repo: str)\n</code></pre> <p>Methods:</p> <ul> <li> <code>release_cksums</code>             \u2013              </li> <li> <code>release_create</code>             \u2013              </li> <li> <code>release_delete</code>             \u2013              </li> <li> <code>release_delete_asset</code>             \u2013              </li> <li> <code>release_download</code>             \u2013              </li> <li> <code>release_exists</code>             \u2013              </li> <li> <code>release_get</code>             \u2013              </li> <li> <code>release_update</code>             \u2013              </li> <li> <code>release_upload</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>owner</code>               (<code>str</code>)           \u2013            </li> <li> <code>repo</code>               (<code>str</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/actions/actions/release/_client.py</code> <pre><code>def __init__(self, owner: str, repo: str) -&gt; None:\n    self._gh = github.get_octokit(http_cache=False)\n    self.owner = owner\n    self.repo = repo\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Client.owner","title":"owner  <code>instance-attribute</code>","text":"<pre><code>owner: str = owner\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Client.repo","title":"repo  <code>instance-attribute</code>","text":"<pre><code>repo: str = repo\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Client.release_cksums","title":"release_cksums  <code>async</code>","text":"<pre><code>release_cksums(tag: str, hasher: str) -&gt; dict[str, str]\n</code></pre> Source code in <code>src/liblaf/actions/actions/release/_client.py</code> <pre><code>async def release_cksums(self, tag: str, hasher: str) -&gt; dict[str, str]:\n    try:\n        data: bytes = await self.release_download(tag, cksum.filename.sums(hasher))\n    except httpx.HTTPStatusError as err:\n        if err.response.status_code == httpx.codes.NOT_FOUND:\n            return {}\n        raise\n    else:\n        return cksum.parse(data)\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Client.release_create","title":"release_create  <code>async</code>","text":"<pre><code>release_create(\n    tag: str,\n    *files: str | PathLike[str],\n    hasher: str | None = None,\n    notes: str | None = None,\n    prerelease: bool = False,\n) -&gt; Release\n</code></pre> Source code in <code>src/liblaf/actions/actions/release/_client.py</code> <pre><code>async def release_create(\n    self,\n    tag: str,\n    *files: str | os.PathLike[str],\n    hasher: str | None = None,\n    notes: str | None = None,\n    prerelease: bool = False,\n) -&gt; ghm.Release:\n    kwargs: dict[str, Any] = (\n        {\"body\": notes, \"generate_release_notes\": False}\n        if notes\n        else {\"generate_release_notes\": True}\n    )\n    resp: githubkit.Response[\n        ghm.Release\n    ] = await self._gh.rest.repos.async_create_release(\n        self.owner,\n        self.repo,\n        tag_name=tag,\n        name=tag,\n        prerelease=prerelease,\n        **kwargs,\n    )\n    release: ghm.Release = resp.parsed_data\n    await self._wait_until_release(tag, exists=True)\n    await self.release_upload(tag, *files, hasher=hasher)\n    return release\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Client.release_delete","title":"release_delete  <code>async</code>","text":"<pre><code>release_delete(tag: str) -&gt; None\n</code></pre> Source code in <code>src/liblaf/actions/actions/release/_client.py</code> <pre><code>async def release_delete(self, tag: str) -&gt; None:\n    with suppress_not_found():\n        release: ghm.Release = await self.release_get(tag)\n        await self._gh.rest.repos.async_delete_release(\n            self.owner, self.repo, release.id\n        )\n    with suppress_not_found():\n        await self._gh.rest.git.async_delete_ref(\n            self.owner, self.repo, f\"tags/{tag}\"\n        )\n    # TODO: remove workaround for [cli/cli#5024 (comment)](https://github.com/cli/cli/issues/5024#issuecomment-1028018586)\n    await self._wait_until_release(tag, exists=False)\n    await asyncio.sleep(5)\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Client.release_delete_asset","title":"release_delete_asset  <code>async</code>","text":"<pre><code>release_delete_asset(tag: str, asset_name: str) -&gt; None\n</code></pre> Source code in <code>src/liblaf/actions/actions/release/_client.py</code> <pre><code>async def release_delete_asset(self, tag: str, asset_name: str) -&gt; None:\n    with suppress_not_found():\n        release: ghm.Release = await self.release_get(tag)\n        for asset in release.assets:\n            if asset.name == asset_name:\n                await self._gh.rest.repos.async_delete_release_asset(\n                    self.owner, self.repo, asset.id\n                )\n                return\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Client.release_download","title":"release_download  <code>async</code>","text":"<pre><code>release_download(tag: str, asset_name: str) -&gt; bytes\n</code></pre> Source code in <code>src/liblaf/actions/actions/release/_client.py</code> <pre><code>async def release_download(self, tag: str, asset_name: str) -&gt; bytes:\n    resp: httpx.Response = await self._gh._arequest(  # noqa: SLF001\n        \"GET\",\n        f\"https://github.com/{self.owner}/{self.repo}/releases/download/{tag}/{asset_name}\",\n    )\n    resp = resp.raise_for_status()\n    return resp.content\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Client.release_exists","title":"release_exists  <code>async</code>","text":"<pre><code>release_exists(tag: str) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/actions/actions/release/_client.py</code> <pre><code>async def release_exists(self, tag: str) -&gt; bool:\n    try:\n        await self.release_get(tag)\n    except githubkit.exception.RequestFailed as err:\n        if err.response.status_code == httpx.codes.NOT_FOUND:\n            return False\n        raise\n    else:\n        return True\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Client.release_get","title":"release_get  <code>async</code>","text":"<pre><code>release_get(tag: str) -&gt; Release\n</code></pre> Source code in <code>src/liblaf/actions/actions/release/_client.py</code> <pre><code>async def release_get(self, tag: str) -&gt; ghm.Release:\n    resp: githubkit.Response[\n        ghm.Release\n    ] = await self._gh.rest.repos.async_get_release_by_tag(\n        self.owner, self.repo, tag\n    )\n    return resp.parsed_data\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Client.release_update","title":"release_update  <code>async</code>","text":"<pre><code>release_update(\n    tag: str, *, body: Missing[str] = UNSET\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/actions/actions/release/_client.py</code> <pre><code>async def release_update(\n    self, tag: str, *, body: githubkit.typing.Missing[str] = githubkit.utils.UNSET\n) -&gt; None:\n    release: ghm.Release = await self.release_get(tag)\n    if not body:\n        return\n    await self._gh.rest.repos.async_update_release(\n        self.owner, self.repo, release.id, body=body\n    )\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Client.release_upload","title":"release_upload  <code>async</code>","text":"<pre><code>release_upload(\n    tag: str,\n    *files: str | PathLike[str],\n    hasher: str | None = None,\n) -&gt; list[ReleaseAsset]\n</code></pre> Source code in <code>src/liblaf/actions/actions/release/_client.py</code> <pre><code>async def release_upload(\n    self, tag: str, *files: str | os.PathLike[str], hasher: str | None = None\n) -&gt; list[ghm.ReleaseAsset]:\n    cksums: dict[str, str]\n    if hasher:\n        cksums = await self.release_cksums(tag, hasher)\n    else:\n        cksums = {}\n    futures: list[Coroutine[Any, Any, ghm.ReleaseAsset]] = []\n    for file in files:\n        fpath: Path = Path(file)\n        data: bytes = fpath.read_bytes()\n        futures.append(self._release_upload_asset(tag, fpath.name, data=data))\n        if hasher:\n            s: str = cksum.hash_bytes(data, hasher)\n            cksums[fpath.name] = s\n            # futures.append(\n            #     self._release_upload_asset(\n            #         tag,\n            #         cksum.filename.single(fpath, hasher),\n            #         data=cksum.dumps({fpath.name: s}).encode(),\n            #     )\n            # )\n    if hasher:\n        futures.append(\n            self._release_upload_asset(\n                tag,\n                cksum.filename.sums(hasher),\n                data=cksum.dumps(cksums).encode(),\n            )\n        )\n    return await asyncio.gather(*futures)\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Inputs","title":"Inputs","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Attributes:</p> <ul> <li> <code>changelog</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>clobber</code>               (<code>bool</code>)           \u2013            </li> <li> <code>files</code>               (<code>list[Path]</code>)           \u2013            </li> <li> <code>hasher</code>               (<code>str</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> <li> <code>prerelease</code>               (<code>bool</code>)           \u2013            </li> <li> <code>repo</code>               (<code>str</code>)           \u2013            </li> <li> <code>tag</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Inputs.changelog","title":"changelog  <code>cached</code> <code>property</code>","text":"<pre><code>changelog: str | None\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Inputs.clobber","title":"clobber  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clobber: bool = False\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Inputs.files","title":"files  <code>cached</code> <code>property</code>","text":"<pre><code>files: list[Path]\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Inputs.hasher","title":"hasher  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hasher: str = 'sha256'\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Inputs.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(env_prefix='INPUT_')\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Inputs.prerelease","title":"prerelease  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prerelease: bool = False\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Inputs.repo","title":"repo  <code>instance-attribute</code>","text":"<pre><code>repo: str\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.Inputs.tag","title":"tag  <code>instance-attribute</code>","text":"<pre><code>tag: str\n</code></pre>"},{"location":"api/liblaf/actions/actions/release/#liblaf.actions.actions.release.main","title":"main  <code>async</code>","text":"<pre><code>main(inputs: Inputs) -&gt; None\n</code></pre> Source code in <code>src/liblaf/actions/actions/release/_main.py</code> <pre><code>@utils.action()\nasync def main(inputs: Inputs) -&gt; None:\n    client = Client(*inputs.repo.split(\"/\"))\n    create: bool = False\n    cksums_local: dict[str, str] = utils.cksum.hash_files(\n        *inputs.files, hasher=inputs.hasher\n    )\n    if await client.release_exists(inputs.tag):\n        cksums_remote: dict[str, str] = await client.release_cksums(\n            inputs.tag, inputs.hasher\n        )\n        if cksums_local == cksums_remote:\n            core.notice(f\"Hashsums match, skip release: {inputs.tag}\")\n            return\n        if inputs.clobber:\n            core.notice(f\"Recreate release: {inputs.tag}\")\n            await client.release_delete(inputs.tag)\n            create = True\n        else:\n            core.notice(f\"Update release: {inputs.tag}\")\n            await client.release_upload(inputs.tag, *inputs.files, hasher=inputs.hasher)\n            await client.release_update(inputs.tag, body=inputs.changelog)\n    else:\n        create = True\n        core.notice(f\"Create release: {inputs.tag}\")\n    if create:\n        await client.release_create(\n            inputs.tag,\n            *inputs.files,\n            hasher=inputs.hasher,\n            notes=inputs.changelog,\n            prerelease=inputs.prerelease,\n        )\n</code></pre>"},{"location":"api/liblaf/actions/actions/review/","title":"liblaf.actions.actions.review","text":"<p>Classes:</p> <ul> <li> <code>Inputs</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>main</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/actions/actions/review/#liblaf.actions.actions.review.Inputs","title":"Inputs","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Attributes:</p> <ul> <li> <code>author</code>               (<code>list[str]</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> <li> <code>repo</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/actions/actions/review/#liblaf.actions.actions.review.Inputs.author","title":"author  <code>cached</code> <code>property</code>","text":"<pre><code>author: list[str]\n</code></pre>"},{"location":"api/liblaf/actions/actions/review/#liblaf.actions.actions.review.Inputs.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(env_prefix='INPUT_')\n</code></pre>"},{"location":"api/liblaf/actions/actions/review/#liblaf.actions.actions.review.Inputs.repo","title":"repo  <code>instance-attribute</code>","text":"<pre><code>repo: str\n</code></pre>"},{"location":"api/liblaf/actions/actions/review/#liblaf.actions.actions.review.main","title":"main  <code>async</code>","text":"<pre><code>main(inputs: Inputs) -&gt; None\n</code></pre> Source code in <code>src/liblaf/actions/actions/review/_main.py</code> <pre><code>@utils.action()\nasync def main(inputs: Inputs) -&gt; None:\n    _: Any\n    gh: githubkit.GitHub = github.get_octokit()\n    owner: str\n    repo: str\n    owner, _, repo = inputs.repo.partition(\"/\")\n    async for pr in gh.paginate(\n        gh.rest.pulls.async_list, owner=owner, repo=repo, state=\"open\"\n    ):\n        if (pr.user is None) or (pr.user.login not in inputs.author):\n            continue\n        async for review in gh.paginate(\n            gh.rest.pulls.async_list_reviews,\n            owner=owner,\n            repo=repo,\n            pull_number=pr.number,\n        ):\n            if review.state == \"APPROVED\" and review.commit_id == pr.head.sha:\n                break\n        else:\n            core.notice(f\"Approve PR: &lt;{pr.html_url}&gt;\")\n            await gh.rest.pulls.async_create_review(\n                owner=owner, repo=repo, pull_number=pr.number, event=\"APPROVE\"\n            )\n</code></pre>"},{"location":"api/liblaf/actions/actions/ruleset_import/","title":"liblaf.actions.actions.ruleset_import","text":"<p>Classes:</p> <ul> <li> <code>Inputs</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>main</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/actions/actions/ruleset_import/#liblaf.actions.actions.ruleset_import.Inputs","title":"Inputs","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Attributes:</p> <ul> <li> <code>model_config</code>           \u2013            </li> <li> <code>repo</code>               (<code>str</code>)           \u2013            </li> <li> <code>source_repo</code>               (<code>str</code>)           \u2013            </li> <li> <code>source_ruleset_id</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/actions/actions/ruleset_import/#liblaf.actions.actions.ruleset_import.Inputs.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(\n    env_prefix=\"INPUT_\", cli_parse_args=True\n)\n</code></pre>"},{"location":"api/liblaf/actions/actions/ruleset_import/#liblaf.actions.actions.ruleset_import.Inputs.repo","title":"repo  <code>instance-attribute</code>","text":"<pre><code>repo: str\n</code></pre>"},{"location":"api/liblaf/actions/actions/ruleset_import/#liblaf.actions.actions.ruleset_import.Inputs.source_repo","title":"source_repo  <code>instance-attribute</code>","text":"<pre><code>source_repo: str\n</code></pre>"},{"location":"api/liblaf/actions/actions/ruleset_import/#liblaf.actions.actions.ruleset_import.Inputs.source_ruleset_id","title":"source_ruleset_id  <code>instance-attribute</code>","text":"<pre><code>source_ruleset_id: int\n</code></pre>"},{"location":"api/liblaf/actions/actions/ruleset_import/#liblaf.actions.actions.ruleset_import.main","title":"main  <code>async</code>","text":"<pre><code>main(inputs: Inputs) -&gt; None\n</code></pre> Source code in <code>src/liblaf/actions/actions/ruleset_import/_main.py</code> <pre><code>@utils.action()\nasync def main(inputs: Inputs) -&gt; None:\n    _: Any\n    gh: githubkit.GitHub = github.get_octokit()\n    owner: str\n    repo: str\n    owner, _, repo = inputs.repo.partition(\"/\")\n    source_owner: str\n    source_repo: str\n    source_owner, _, source_repo = inputs.source_repo.partition(\"/\")\n    source_ruleset: ghm.RepositoryRuleset = (\n        await gh.rest.repos.async_get_repo_ruleset(\n            source_owner, source_repo, inputs.source_ruleset_id\n        )\n    ).parsed_data\n    target_ruleset: ghm.RepositoryRuleset | None = await find_ruleset(\n        owner, repo, source_ruleset.name\n    )\n    if target_ruleset is not None:\n        await update_ruleset(owner, repo, source_ruleset, target_ruleset.id)\n    else:\n        await create_ruleset(owner, repo, source_ruleset)\n</code></pre>"},{"location":"api/liblaf/actions/core/","title":"liblaf.actions.core","text":"<p>Functions:</p> <ul> <li> <code>get_input</code>             \u2013              </li> <li> <code>get_multiline_input</code>             \u2013              </li> <li> <code>notice</code>             \u2013              </li> <li> <code>set_output</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/actions/core/#liblaf.actions.core.get_input","title":"get_input","text":"<pre><code>get_input(name: str) -&gt; str\n</code></pre> Source code in <code>src/liblaf/actions/core/_core.py</code> <pre><code>def get_input(name: str) -&gt; str:\n    val: str = input_env.str(name.replace(\" \", \"_\").upper(), \"\")\n    return val.strip()\n</code></pre>"},{"location":"api/liblaf/actions/core/#liblaf.actions.core.get_multiline_input","title":"get_multiline_input","text":"<pre><code>get_multiline_input(name: str) -&gt; list[str]\n</code></pre> Source code in <code>src/liblaf/actions/core/_core.py</code> <pre><code>def get_multiline_input(name: str) -&gt; list[str]:\n    return list(actions.utils.splitlines(get_input(name)))\n</code></pre>"},{"location":"api/liblaf/actions/core/#liblaf.actions.core.notice","title":"notice","text":"<pre><code>notice(message: str) -&gt; None\n</code></pre> Source code in <code>src/liblaf/actions/core/_core.py</code> <pre><code>def notice(message: str) -&gt; None:\n    print(f\"::notice::{message}\")\n</code></pre>"},{"location":"api/liblaf/actions/core/#liblaf.actions.core.set_output","title":"set_output","text":"<pre><code>set_output(\n    name: str, value: Any, *, delimiter: str = \"EOF\"\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/actions/core/_core.py</code> <pre><code>def set_output(name: str, value: Any, *, delimiter: str = \"EOF\") -&gt; None:\n    fpath: Path = env.path(\"GITHUB_OUTPUT\")\n    value = str(value)\n    with fpath.open(\"a\") as fp:\n        if \"\\n\" in value:\n            # ref: &lt;https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions#multiline-strings&gt;\n            fp.write(f\"{name}&lt;&lt;{delimiter}\\n{value}\\n{delimiter}\\n\")\n        else:\n            fp.write(f\"{name}={value}\\n\")\n</code></pre>"},{"location":"api/liblaf/actions/github/","title":"liblaf.actions.github","text":"<p>Classes:</p> <ul> <li> <code>AppClient</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>get_octokit</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/actions/github/#liblaf.actions.github.AppClient","title":"AppClient","text":"<pre><code>AppClient(gh: GitHub)\n</code></pre> <p>Methods:</p> <ul> <li> <code>list_installations</code>             \u2013              </li> <li> <code>list_repos_accessible_to_installation</code>             \u2013              </li> </ul> Source code in <code>src/liblaf/actions/github/_app.py</code> <pre><code>def __init__(self, gh: githubkit.GitHub) -&gt; None:\n    self._gh = gh\n</code></pre>"},{"location":"api/liblaf/actions/github/#liblaf.actions.github.AppClient.list_installations","title":"list_installations  <code>async</code>","text":"<pre><code>list_installations() -&gt; AsyncGenerator[Installation, Any]\n</code></pre> Source code in <code>src/liblaf/actions/github/_app.py</code> <pre><code>async def list_installations(self) -&gt; AsyncGenerator[m.Installation, Any]:\n    for page in itertools.count(1):\n        installations: list[m.Installation] = (\n            await self._gh.rest.apps.async_list_installations(page=page)\n        ).parsed_data\n        if not installations:\n            break\n        for installation in installations:\n            yield installation\n</code></pre>"},{"location":"api/liblaf/actions/github/#liblaf.actions.github.AppClient.list_repos_accessible_to_installation","title":"list_repos_accessible_to_installation  <code>async</code>","text":"<pre><code>list_repos_accessible_to_installation() -&gt; (\n    AsyncGenerator[Repository, Any]\n)\n</code></pre> Source code in <code>src/liblaf/actions/github/_app.py</code> <pre><code>async def list_repos_accessible_to_installation(\n    self,\n) -&gt; AsyncGenerator[m.Repository, Any]:\n    total_count: int = 0\n    for page in itertools.count(1):\n        resp: m.InstallationRepositoriesGetResponse200 = (\n            await self._gh.rest.apps.async_list_repos_accessible_to_installation(\n                page=page\n            )\n        ).parsed_data\n        for repo in resp.repositories:\n            yield repo\n        total_count += len(resp.repositories)\n        if total_count &gt;= resp.total_count:\n            break\n</code></pre>"},{"location":"api/liblaf/actions/github/#liblaf.actions.github.get_octokit","title":"get_octokit","text":"<pre><code>get_octokit(*, http_cache: bool = True) -&gt; GitHub\n</code></pre> Source code in <code>src/liblaf/actions/github/_github.py</code> <pre><code>def get_octokit(*, http_cache: bool = True) -&gt; githubkit.GitHub:\n    token: str | None = (\n        env.str(\"INPUT_TOKEN\", None)\n        or env.str(\"INPUT_GITHUB_TOKEN\", None)\n        or env.str(\"GH_TOKEN\", None)\n        or env.str(\"GITHUB_TOKEN\", None)\n    )\n    return githubkit.GitHub(token, http_cache=http_cache)\n</code></pre>"},{"location":"api/liblaf/actions/utils/","title":"liblaf.actions.utils","text":"<p>Modules:</p> <ul> <li> <code>cksum</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>action</code>             \u2013              </li> <li> <code>init_logging</code>             \u2013              </li> <li> <code>run</code>             \u2013              </li> <li> <code>splitlines</code>             \u2013              </li> </ul>"},{"location":"api/liblaf/actions/utils/#liblaf.actions.utils.action","title":"action","text":"<pre><code>action() -&gt; Callable[[RawAction], WrappedAction]\n</code></pre> Source code in <code>src/liblaf/actions/utils/_action.py</code> <pre><code>def action() -&gt; Callable[[RawAction], WrappedAction]:\n    def decorator(fn: RawAction[_S_contra]) -&gt; WrappedAction:\n        @functools.wraps(fn)\n        def wrapped() -&gt; None:\n            utils.init_logging()\n            sig: inspect.Signature = inspect.signature(fn)\n            param: inspect.Parameter = next(iter(sig.parameters.values()))\n            annotation: type[_S_contra] = param.annotation\n            inputs: _S_contra = annotation()\n            asyncio.run(fn(inputs))\n\n        return wrapped\n\n    return decorator\n</code></pre>"},{"location":"api/liblaf/actions/utils/#liblaf.actions.utils.init_logging","title":"init_logging","text":"<pre><code>init_logging(level: str | int = NOTSET) -&gt; None\n</code></pre> Source code in <code>src/liblaf/actions/utils/_logging.py</code> <pre><code>def init_logging(level: str | int = logging.NOTSET) -&gt; None:\n    if level in (logging.NOTSET, \"NOTSET\"):\n        level = \"DEBUG\" if env.bool(\"RUNNER_DEBUG\", False) else \"INFO\"\n    grapes.init_logging(level=level)\n</code></pre>"},{"location":"api/liblaf/actions/utils/#liblaf.actions.utils.run","title":"run  <code>async</code>","text":"<pre><code>run(\n    *args: StrPath,\n    capture_stdout: Literal[False] = False,\n    text: bool = False,\n) -&gt; None\n</code></pre><pre><code>run(\n    *args: StrPath,\n    capture_stdout: Literal[True],\n    text: Literal[False] = False,\n) -&gt; bytes\n</code></pre><pre><code>run(\n    *args: StrPath,\n    capture_stdout: Literal[True],\n    text: Literal[True],\n) -&gt; str\n</code></pre> <pre><code>run(\n    *args: StrPath,\n    capture_stdout: bool = False,\n    text: bool = False,\n) -&gt; str | bytes | None\n</code></pre> Source code in <code>src/liblaf/actions/utils/_subprocess.py</code> <pre><code>async def run(\n    *args: StrPath, capture_stdout: bool = False, text: bool = False\n) -&gt; str | bytes | None:\n    proc: asp.Process = await asyncio.create_subprocess_exec(\n        *[str(a) for a in args], stdout=asp.PIPE if capture_stdout else None\n    )\n    output: bytes = b\"\"\n    if capture_stdout:\n        assert proc.stdout is not None\n        output = await proc.stdout.read()\n    returncode: int = await proc.wait()\n    if returncode != 0:\n        raise sp.CalledProcessError(returncode, args)\n    if capture_stdout:\n        if text:\n            return output.decode()\n        return output\n    return None\n</code></pre>"},{"location":"api/liblaf/actions/utils/#liblaf.actions.utils.splitlines","title":"splitlines","text":"<pre><code>splitlines(s: str) -&gt; Generator[str]\n</code></pre> Source code in <code>src/liblaf/actions/utils/_text.py</code> <pre><code>def splitlines(s: str) -&gt; Generator[str]:\n    for line in s.strip().splitlines():\n        line_stripped: str = line.strip()\n        if line_stripped:\n            yield line_stripped\n</code></pre>"},{"location":"api/liblaf/actions/utils/cksum/","title":"liblaf.actions.utils.cksum","text":"<p>Modules:</p> <ul> <li> <code>filename</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>dump</code>             \u2013              </li> <li> <code>dumps</code>             \u2013              </li> <li> <code>hash_bytes</code>             \u2013              </li> <li> <code>hash_file</code>             \u2013              </li> <li> <code>hash_files</code>             \u2013              </li> <li> <code>parse</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>DEFAULT_HASHER</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/actions/utils/cksum/#liblaf.actions.utils.cksum.DEFAULT_HASHER","title":"DEFAULT_HASHER  <code>module-attribute</code>","text":"<pre><code>DEFAULT_HASHER: str = 'sha256'\n</code></pre>"},{"location":"api/liblaf/actions/utils/cksum/#liblaf.actions.utils.cksum.dump","title":"dump","text":"<pre><code>dump(\n    data: dict[str, str], fpath: str | PathLike[str]\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/actions/utils/cksum/_sumfile.py</code> <pre><code>def dump(data: dict[str, str], fpath: str | os.PathLike[str]) -&gt; None:\n    fpath = Path(fpath)\n    fpath.write_text(dumps(data))\n</code></pre>"},{"location":"api/liblaf/actions/utils/cksum/#liblaf.actions.utils.cksum.dumps","title":"dumps","text":"<pre><code>dumps(data: dict[str, str]) -&gt; str\n</code></pre> Source code in <code>src/liblaf/actions/utils/cksum/_sumfile.py</code> <pre><code>def dumps(data: dict[str, str]) -&gt; str:\n    text: str = \"\"\n    for filename, hashsum in sorted(data.items()):\n        text += f\"{hashsum}  {filename}\\n\"\n    return text\n</code></pre>"},{"location":"api/liblaf/actions/utils/cksum/#liblaf.actions.utils.cksum.hash_bytes","title":"hash_bytes","text":"<pre><code>hash_bytes(\n    data: bytes, hasher: str = DEFAULT_HASHER\n) -&gt; str\n</code></pre> Source code in <code>src/liblaf/actions/utils/cksum/_hashsum.py</code> <pre><code>def hash_bytes(data: bytes, hasher: str = DEFAULT_HASHER) -&gt; str:\n    hasher: hashlib._Hash = hashlib.new(hasher)\n    hasher.update(data)\n    return hasher.hexdigest()\n</code></pre>"},{"location":"api/liblaf/actions/utils/cksum/#liblaf.actions.utils.cksum.hash_file","title":"hash_file  <code>cached</code>","text":"<pre><code>hash_file(\n    fpath: str | PathLike[str], hasher: str = DEFAULT_HASHER\n) -&gt; str\n</code></pre> Source code in <code>src/liblaf/actions/utils/cksum/_hashsum.py</code> <pre><code>@functools.lru_cache\ndef hash_file(fpath: str | os.PathLike[str], hasher: str = DEFAULT_HASHER) -&gt; str:\n    fpath = Path(fpath)\n    with fpath.open(\"rb\") as fp:\n        hasher: hashlib._Hash = hashlib.file_digest(fp, hasher)\n        return hasher.hexdigest()\n</code></pre>"},{"location":"api/liblaf/actions/utils/cksum/#liblaf.actions.utils.cksum.hash_files","title":"hash_files","text":"<pre><code>hash_files(\n    *files: str | PathLike[str],\n    hasher: str = DEFAULT_HASHER,\n) -&gt; dict[str, str]\n</code></pre> Source code in <code>src/liblaf/actions/utils/cksum/_hashsum.py</code> <pre><code>def hash_files(\n    *files: str | os.PathLike[str], hasher: str = DEFAULT_HASHER\n) -&gt; dict[str, str]:\n    result: dict[str, str] = {}\n    for _file in files:\n        fpath = Path(_file)\n        result[fpath.name] = hash_file(fpath, hasher)\n    return result\n</code></pre>"},{"location":"api/liblaf/actions/utils/cksum/#liblaf.actions.utils.cksum.parse","title":"parse","text":"<pre><code>parse(text: str | bytes) -&gt; dict[str, str]\n</code></pre> Source code in <code>src/liblaf/actions/utils/cksum/_sumfile.py</code> <pre><code>def parse(text: str | bytes) -&gt; dict[str, str]:\n    result: dict[str, str] = {}\n    for line in utils.splitlines(text if isinstance(text, str) else text.decode()):\n        hashsum: str\n        filename: str\n        hashsum, filename = line.split()\n        result[filename] = hashsum\n    return result\n</code></pre>"},{"location":"api/liblaf/actions/utils/cksum/filename/","title":"liblaf.actions.utils.cksum.filename","text":"<p>Functions:</p> <ul> <li> <code>single</code>             \u2013              </li> <li> <code>sums</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>FILENAMES</code>               (<code>dict[str, str]</code>)           \u2013            </li> </ul>"},{"location":"api/liblaf/actions/utils/cksum/filename/#liblaf.actions.utils.cksum.filename.FILENAMES","title":"FILENAMES  <code>module-attribute</code>","text":"<pre><code>FILENAMES: dict[str, str] = {'blake2b': 'b2sums.txt'}\n</code></pre>"},{"location":"api/liblaf/actions/utils/cksum/filename/#liblaf.actions.utils.cksum.filename.single","title":"single","text":"<pre><code>single(\n    fpath: str | PathLike[str], hasher: str = DEFAULT_HASHER\n) -&gt; str\n</code></pre> Source code in <code>src/liblaf/actions/utils/cksum/filename.py</code> <pre><code>def single(fpath: str | os.PathLike[str], hasher: str = DEFAULT_HASHER) -&gt; str:\n    fpath: Path = Path(fpath)\n    return fpath.name + \".\" + hasher\n</code></pre>"},{"location":"api/liblaf/actions/utils/cksum/filename/#liblaf.actions.utils.cksum.filename.sums","title":"sums","text":"<pre><code>sums(hasher: str = DEFAULT_HASHER) -&gt; str\n</code></pre> Source code in <code>src/liblaf/actions/utils/cksum/filename.py</code> <pre><code>def sums(hasher: str = DEFAULT_HASHER) -&gt; str:\n    if hasher in FILENAMES:\n        return FILENAMES[hasher]\n    return hasher + \"sums.txt\"\n</code></pre>"}]}